import pandas as pd
import os
import sys

# Paths (Adjust relative paths as needed)
BIGREC_DIR = 'BIGRec/data/game_bigrec'
DLLM2REC_DIR = 'BIGRec/data/game_bigrec' # process.py saves DLLM2Rec data here too

def verify_alignment():
    print("Verifying ID Alignment for game_bigrec...")
    
    # 1. Load id2name.txt (BIGRec Mapping)
    # Format: Title\tID
    id2name_path = os.path.join(BIGREC_DIR, 'id2name.txt')
    if not os.path.exists(id2name_path):
        print(f"Error: {id2name_path} not found.")
        return

    print(f"Loading {id2name_path}...")
    bigrec_map = {}
    with open(id2name_path, 'r') as f:
        for line in f:
            parts = line.strip().split('\t')
            if len(parts) >= 2:
                # Assuming ID is last
                iid = int(parts[-1])
                title = parts[0]
                bigrec_map[title] = iid
    
    print(f"Loaded {len(bigrec_map)} items from BIGRec map.")
    
    # 2. Load DLLM2Rec train_data.df
    train_df_path = os.path.join(DLLM2REC_DIR, 'train_data.df')
    if not os.path.exists(train_df_path):
        print(f"Error: {train_df_path} not found.")
        return

    print(f"Loading {train_df_path}...")
    train_df = pd.read_pickle(train_df_path)
    print(f"Loaded {len(train_df)} rows from DLLM2Rec train data.")
    
    # Check simple consistency check
    # Pick a random row
    sample_row = train_df.iloc[0]
    
    # DLLM2Rec ID
    dllm_target_id = sample_row['next']
    print(f"Sample Row 0 Target ID (DLLM2Rec 1-based): {dllm_target_id}")
    
    # BIGRec Equivalent
    # We need to find the Item Title that corresponds to this ID.
    # But we don't have ID->Title map easily for DLLM2Rec unless we reverse logic.
    # process.py logic: output_id = input_id + 1.
    # input_id in process.py was from item2id which is 0-based.
    # So BIGRec ID (0-based) = DLLM2Rec ID - 1.
    
    bigrec_equivalent_id = dllm_target_id - 1
    print(f"Hypothesized BIGRec ID (0-based): {bigrec_equivalent_id}")
    
    # Verify bounds
    if bigrec_equivalent_id not in bigrec_map.values():
         print(f"WARNING: Hypothesized ID {bigrec_equivalent_id} not found in id2name.txt values!")
    else:
         print(f"Confirmed {bigrec_equivalent_id} exists in BIGRec map.")
         
    # 3. Simulate Transfer Mismatch
    # If BIGRec predicts this item perfectly, it outputs rank index: bigrec_equivalent_id.
    # DLLM2Rec main.py loads this index as 'candidate'.
    # DLLM2Rec main.py gathers score from model_output at index 'candidate'.
    # model_output indices correspond to DLLM2Rec IDs?
    # SASRec model output size is `item_num + 1` (Count + 2).
    # Indices are 0, 1, ..., Count+1.
    # Item 1 is at index 1.
    # If we access index `bigrec_equivalent_id` (which is `dllm_target_id - 1`),
    # We are accessing index `Item ID - 1`.
    # E.g., Target is Item 1. We access index 0.
    # THIS IS THE MISMATCH.
    
    print("\n--- MISMATCH DIAGNOSIS ---")
    print(f"Target Item (DLLM2Rec ID): {dllm_target_id}")
    print(f"BIGRec Rank/Index (generated by evaluate.py): {bigrec_equivalent_id}")
    print(f"DLLM2Rec Model Access Index (if using BIGRec Rank directly): {bigrec_equivalent_id}")
    print(f"Correct Model Access Index (should be same as ID): {dllm_target_id}")
    
    if bigrec_equivalent_id != dllm_target_id:
        print("FAIL: Indices imply mismatch! access_index != correct_index")
        print("explanation: BIGRec returns 0-based index. DLLM2Rec model uses 1-based indexing output.")
        
        # Simulate Fix
        fixed_index = bigrec_equivalent_id + 1
        print(f"\n[SIMULATING FIX] Adding +1 to BIGRec Index: {bigrec_equivalent_id} -> {fixed_index}")
        
        if fixed_index == dllm_target_id:
            print("PASS: Fixed Index matches Target ID. The +1 fix is valid.")
        else:
             print("FAIL: Even with +1, IDs do not match!")
    else:
        print("PASS: Indices match (Unexpected).")

if __name__ == "__main__":
    verify_alignment()
